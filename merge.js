// ç¡¬ç¼–ç å‚æ•°ç‰ˆæœ¬
log(`ğŸš€ğŸš€ å¼€å§‹`)

// ç¡¬ç¼–ç å‚æ•° - åœ¨è¿™é‡Œä¿®æ”¹é…ç½®
const type = null;           // è®¢é˜…ç±»å‹ï¼šç»„åˆè®¢é˜… æˆ– null
const name = "feiniaoyun";              // è®¢é˜…åç§°
const url = null;                      // è®¢é˜…URLï¼Œè®¾ä¸ºnullä½¿ç”¨æœ¬åœ°è®¢é˜…
const outbound = "ğŸ•³ğŸˆ è‡ªåŠ¨é€‰æ‹©ğŸ•³ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹ğŸ·^(?=.*(æ¸¯|HK|hk|Hong Kong|HongKong|hongkong)).*$ğŸ•³ğŸ‡¹ğŸ‡¼ å°æ¹¾èŠ‚ç‚¹ğŸ·^(?=.*(å°|æ–°åŒ—|å½°åŒ–|TW|Taiwan)).*$ğŸ•³ğŸ‡¯ğŸ‡µ æ—¥æœ¬èŠ‚ç‚¹ğŸ·^(?=.*(æ—¥æœ¬|å·æ—¥|ä¸œäº¬|å¤§é˜ª|æ³‰æ—¥|åŸ¼ç‰|æ²ªæ—¥|æ·±æ—¥|[^-]æ—¥|JP|Japan)).*$ğŸ•³ğŸ‡¸ğŸ‡¬ æ–°åŠ å¡èŠ‚ç‚¹ğŸ·^(?=.*(æ–°åŠ å¡|å¡|ç‹®åŸ|SG|Singapore)).*$ğŸ•³ğŸ‡ºğŸ‡¸ ç¾å›½èŠ‚ç‚¹ğŸ·^(?=.*(ç¾|æ³¢ç‰¹å…°|è¾¾æ‹‰æ–¯|ä¿„å‹’å†ˆ|å‡¤å‡°åŸ|è´¹åˆ©è’™|ç¡…è°·|æ‹‰æ–¯ç»´åŠ æ–¯|æ´›æ‰çŸ¶|åœ£ä½•å¡|åœ£å…‹æ‹‰æ‹‰|è¥¿é›…å›¾|èŠåŠ å“¥|US|United States)).*$ğŸ•³ğŸ§­ å…¶å®ƒåœ°åŒºğŸ·^(?!.*(æ¸¯|HK|hk|Hong Kong|HongKong|hongkong|æ—¥æœ¬|å·æ—¥|ä¸œäº¬|å¤§é˜ª|æ³‰æ—¥|åŸ¼ç‰|æ²ªæ—¥|æ·±æ—¥|[^-]æ—¥|JP|Japan|ç¾|æ³¢ç‰¹å…°|è¾¾æ‹‰æ–¯|ä¿„å‹’å†ˆ|å‡¤å‡°åŸ|è´¹åˆ©è’™|ç¡…è°·|æ‹‰æ–¯ç»´åŠ æ–¯|æ´›æ‰çŸ¶|åœ£ä½•å¡|åœ£å…‹æ‹‰æ‹‰|è¥¿é›…å›¾|èŠåŠ å“¥|US|United States|å°|æ–°åŒ—|å½°åŒ–|TW|Taiwan|æ–°åŠ å¡|å¡|ç‹®åŸ|SG|Singapore|ç¾|ç½‘æ˜“|Netease|å¥—é¤|é‡ç½®|å‰©ä½™|åˆ°æœŸ|è®¢é˜…|ç¾¤|è´¦æˆ·|æµé‡|æœ‰æ•ˆæœŸ|æ—¶é—´|å®˜ç½‘)).*$";
const includeUnsupportedProxy = false;  // æ˜¯å¦åŒ…å«ä¸æ”¯æŒçš„åè®®

// åŸè„šæœ¬ï¼š
// https://gh-proxy.org/https://github.com/xream/scripts/raw/refs/heads/main/surge/modules/sub-store-scripts/sing-box/template.js#name=feiniaoyun&outbound=ğŸ•³âš¡ å»¶è¿Ÿæœ€ä½ğŸ•³ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹ğŸ·^(?=.*(æ¸¯|HK|hk|Hong Kong|HongKong|hongkong)).*$ğŸ•³ğŸ‡¹ğŸ‡¼ å°æ¹¾èŠ‚ç‚¹ğŸ·^(?=.*(å°|æ–°åŒ—|å½°åŒ–|TW|Taiwan)).*$ğŸ•³ğŸ‡¯ğŸ‡µ æ—¥æœ¬èŠ‚ç‚¹ğŸ·^(?=.*(æ—¥æœ¬|å·æ—¥|ä¸œäº¬|å¤§é˜ª|æ³‰æ—¥|åŸ¼ç‰|æ²ªæ—¥|æ·±æ—¥|[^-]æ—¥|JP|Japan)).*$ğŸ•³ğŸ‡¸ğŸ‡¬ æ–°åŠ å¡èŠ‚ç‚¹ğŸ·^(?=.*(æ–°åŠ å¡|å¡|ç‹®åŸ|SG|Singapore)).*$ğŸ•³ğŸ‡ºğŸ‡¸ ç¾å›½èŠ‚ç‚¹ğŸ·^(?=.*(ç¾|æ³¢ç‰¹å…°|è¾¾æ‹‰æ–¯|ä¿„å‹’å†ˆ|å‡¤å‡°åŸ|è´¹åˆ©è’™|ç¡…è°·|æ‹‰æ–¯ç»´åŠ æ–¯|æ´›æ‰çŸ¶|åœ£ä½•å¡|åœ£å…‹æ‹‰æ‹‰|è¥¿é›…å›¾|èŠåŠ å“¥|US|United States)).*$ğŸ•³ğŸ§­ å…¶å®ƒåœ°åŒºğŸ·^(?!.*(æ¸¯|HK|hk|Hong Kong|HongKong|hongkong|æ—¥æœ¬|å·æ—¥|ä¸œäº¬|å¤§é˜ª|æ³‰æ—¥|åŸ¼ç‰|æ²ªæ—¥|æ·±æ—¥|[^-]æ—¥|JP|Japan|ç¾|æ³¢ç‰¹å…°|è¾¾æ‹‰æ–¯|ä¿„å‹’å†ˆ|å‡¤å‡°åŸ|è´¹åˆ©è’™|ç¡…è°·|æ‹‰æ–¯ç»´åŠ æ–¯|æ´›æ‰çŸ¶|åœ£ä½•å¡|åœ£å…‹æ‹‰æ‹‰|è¥¿é›…å›¾|èŠåŠ å“¥|US|United States|å°|æ–°åŒ—|å½°åŒ–|TW|Taiwan|æ–°åŠ å¡|å¡|ç‹®åŸ|SG|Singapore|ç¾|ç½‘æ˜“|Netease|å¥—é¤|é‡ç½®|å‰©ä½™|åˆ°æœŸ|è®¢é˜…|ç¾¤|è´¦æˆ·|æµé‡|æœ‰æ•ˆæœŸ|æ—¶é—´|å®˜ç½‘)).*$

log(`ç¡¬ç¼–ç å‚æ•° type: ${type}, name: ${name}, outbound: ${outbound}`)

const parsedType = /^1$|col|ç»„åˆ/i.test(type) ? 'collection' : 'subscription';

const parser = ProxyUtils.JSON5 || JSON
log(`â‘  ä½¿ç”¨ ${ProxyUtils.JSON5 ? 'JSON5' : 'JSON'} è§£æé…ç½®æ–‡ä»¶`)
let config
try {
  config = parser.parse($content ?? $files[0])
} catch (e) {
  log(`${e.message ?? e}`)
  throw new Error(`é…ç½®æ–‡ä»¶ä¸æ˜¯åˆæ³•çš„ ${ProxyUtils.JSON5 ? 'JSON5' : 'JSON'} æ ¼å¼`)
}
log(`â‘¡ è·å–è®¢é˜…`)

let proxies
if (url) {
  log(`ç›´æ¥ä» URL ${url} è¯»å–è®¢é˜…`)
  proxies = await produceArtifact({
    name,
    type: parsedType,
    platform: 'sing-box',
    produceType: 'internal',
    produceOpts: {
      'include-unsupported-proxy': includeUnsupportedProxy,
    },
    subscription: {
      name,
      url,
      source: 'remote',
    },
  })
} else {
  log(`å°†è¯»å–åç§°ä¸º ${name} çš„ ${parsedType === 'collection' ? 'ç»„åˆ' : ''}è®¢é˜…`)
  proxies = await produceArtifact({
    name,
    type: parsedType,
    platform: 'sing-box',
    produceType: 'internal',
    produceOpts: {
      'include-unsupported-proxy': includeUnsupportedProxy,
    },
  })
}

log(`â‘¢ outbound è§„åˆ™è§£æ`)
const outbounds = outbound
  .split('ğŸ•³')
  .filter(i => i)
  .map(i => {
    let [outboundPattern, tagPattern = '.*'] = i.split('ğŸ·')
    const tagRegex = createTagRegExp(tagPattern)
    log(`åŒ¹é… ğŸ· ${tagRegex} çš„èŠ‚ç‚¹å°†æ’å…¥åŒ¹é… ğŸ•³ ${createOutboundRegExp(outboundPattern)} çš„ outbound ä¸­`)
    return [outboundPattern, tagRegex]
  })

log(`â‘£ outbound æ’å…¥èŠ‚ç‚¹`)
config.outbounds.map(outbound => {
  outbounds.map(([outboundPattern, tagRegex]) => {
    const outboundRegex = createOutboundRegExp(outboundPattern)
    if (outboundRegex.test(outbound.tag)) {
      if (!Array.isArray(outbound.outbounds)) {
        outbound.outbounds = []
      }
      const tags = getTags(proxies, tagRegex)
      log(`ğŸ•³ ${outbound.tag} åŒ¹é… ${outboundRegex}, æ’å…¥ ${tags.length} ä¸ª ğŸ· åŒ¹é… ${tagRegex} çš„èŠ‚ç‚¹`)
      outbound.outbounds.push(...tags)
    }
  })
})

const compatible_outbound = {
  tag: 'COMPATIBLE',
  type: 'direct',
}

let compatible
log(`â‘¤ ç©º outbounds æ£€æŸ¥`)
config.outbounds.map(outbound => {
  outbounds.map(([outboundPattern, tagRegex]) => {
    const outboundRegex = createOutboundRegExp(outboundPattern)
    if (outboundRegex.test(outbound.tag)) {
      if (!Array.isArray(outbound.outbounds)) {
        outbound.outbounds = []
      }
      if (outbound.outbounds.length === 0) {
        if (!compatible) {
          config.outbounds.push(compatible_outbound)
          compatible = true
        }
        log(`ğŸ•³ ${outbound.tag} çš„ outbounds ä¸ºç©º, è‡ªåŠ¨æ’å…¥ COMPATIBLE(direct)`)
        outbound.outbounds.push(compatible_outbound.tag)
      }
    }
  })
})

config.outbounds.push(...proxies)

$content = JSON.stringify(config, null, 2)

function getTags(proxies, regex) {
  return (regex ? proxies.filter(p => regex.test(p.tag)) : proxies).map(p => p.tag)
}
function log(v) {
  console.log(`[ğŸ“¦ sing-box æ¨¡æ¿è„šæœ¬] ${v}`)
}
function createTagRegExp(tagPattern) {
  return new RegExp(tagPattern.replace('â„¹ï¸', ''), tagPattern.includes('â„¹ï¸') ? 'i' : undefined)
}
function createOutboundRegExp(outboundPattern) {
  return new RegExp(outboundPattern.replace('â„¹ï¸', ''), outboundPattern.includes('â„¹ï¸') ? 'i' : undefined)
}

log(`ğŸ”š ç»“æŸ`)